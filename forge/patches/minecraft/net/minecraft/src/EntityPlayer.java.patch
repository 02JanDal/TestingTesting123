--- ../src_base/minecraft/net/minecraft/src/EntityPlayer.java	0000-00-00 00:00:00.000000000 -0000
+++ ../src_work/minecraft/net/minecraft/src/EntityPlayer.java	0000-00-00 00:00:00.000000000 -0000
@@ -2,6 +2,10 @@
 
 import java.util.*;
 
+import net.minecraft.src.forge.ArmorProperties;
+import net.minecraft.src.forge.ForgeHooks;
+import net.minecraft.src.forge.ISpecialArmor;
+
 public abstract class EntityPlayer extends EntityLiving
 {
     public InventoryPlayer inventory;
@@ -149,6 +153,7 @@
             }
             else
             {
+            	itemInUse.getItem().onUsingItemTick(itemInUse, this, itemInUseCount);
                 if (itemInUseCount <= 25 && itemInUseCount % 4 == 0)
                 {
                     func_35201_a(itemstack, 5);
@@ -490,7 +495,16 @@
 
     public void dropCurrentItem()
     {
-        dropPlayerItemWithRandomChoice(inventory.decrStackSize(inventory.currentItem, 1), false);
+    	ItemStack stack = inventory.getCurrentItem();
+    	if (stack == null)
+    	{
+    		return;
+    	}    	
+    	
+    	if (stack.getItem().onDroppedByPlayer(stack, this))
+    	{
+            dropPlayerItemWithRandomChoice(inventory.decrStackSize(inventory.currentItem, 1), false);
+    	}
     }
 
     public void dropPlayerItem(ItemStack itemstack)
@@ -537,6 +551,9 @@
         worldObj.spawnEntityInWorld(entityitem);
     }
 
+    /* FORGE: This isnt called anymore
+     */
+    @Deprecated
     public float getCurrentPlayerStrVsBlock(Block block)
     {
         float f = inventory.getStrVsBlock(block);
@@ -565,6 +582,45 @@
         return f1;
     }
 
+    /* FORGE: Extended to allow metadata.
+     */
+    public float getCurrentPlayerStrVsBlock(Block block, int md)
+    {
+        float f = 1.0F;
+        ItemStack ist = inventory.getCurrentItem();
+        if(ist != null)
+        {
+        	f = ist.getItem().getStrVsBlock(ist, block, md);
+        }
+        
+        int i = EnchantmentHelper.getEfficiencyModifier(inventory);
+        if (i > 0 && ForgeHooks.canHarvestBlock(block, this, md))
+        {
+        	f += i * i + 1;
+        }
+        
+        if(isPotionActive(Potion.digSpeed))
+        {
+            f *= 1.0F + (float)(getActivePotionEffect(Potion.digSpeed).getAmplifier() + 1) * 0.2F;
+        }
+        
+        if(isPotionActive(Potion.digSlowdown))
+        {
+            f *= 1.0F - (float)(getActivePotionEffect(Potion.digSlowdown).getAmplifier() + 1) * 0.2F;
+        }
+        
+        if(isInsideOfMaterial(Material.water) && !EnchantmentHelper.getAquaAffinityModifier(inventory))
+        {
+            f /= 5F;
+        }
+        
+        if(!onGround)
+        {
+            f /= 5F;
+        }
+        return f;
+    }
+
     public boolean canHarvestBlock(Block block)
     {
         return inventory.canHarvestBlock(block);
@@ -768,8 +824,54 @@
         {
             i = 1 + i >> 1;
         }
-        i = applyArmorCalculations(damagesource, i);
-        i = applyPotionDamageCalculations(damagesource, i);
+        
+        int absorb = 0;
+        int reduce = 0;
+        
+        for (int x = 0; x < inventory.armorInventory.length; x++) 
+        {
+            ItemStack stack = inventory.armorInventory[x];
+            if (stack == null)
+            {
+                continue;
+            }
+            
+            if (stack.getItem() instanceof ISpecialArmor) 
+            {
+                ISpecialArmor armor = (ISpecialArmor)stack.getItem();                
+                ArmorProperties props = armor.getProperties(this, damagesource, stack, i);
+                absorb += props.damageAbsorb;
+                reduce += props.damageReduce;
+            } 
+            else if (stack.getItem() instanceof ItemArmor && !damagesource.isUnblockable())
+            {
+                reduce += ((ItemArmor)stack.getItem()).damageReduceAmount / 25.0;
+                stack.damageItem((i / 4 == 0 ? 1 : i / 4), this);
+            }
+            
+            if (inventory.armorInventory[x] != null)
+            {
+                stack.onItemDestroyedByUse(this);
+                inventory.armorInventory[x] = null;
+            }
+        }
+        
+        i -= absorb;
+        if (i <= 0)
+        {
+            return;
+        }
+        
+        reduce = Math.min(25, 25 * reduce);
+        int damage = i * (25 - reduce) + carryoverDamage;
+        carryoverDamage = damage % 25;
+        damage /= 25;
+        if (damage <= 0)
+        {
+            return;
+        }
+        
+        i = applyPotionDamageCalculations(damagesource, damage);
         addExhaustion(damagesource.getHungerDamage());
         health -= i;
     }
@@ -815,7 +917,9 @@
 
     public void destroyCurrentEquippedItem()
     {
+    	ItemStack orig = inventory.getCurrentItem();
         inventory.setInventorySlotContents(inventory.currentItem, null);
+        ForgeHooks.onDestroyCurrentItem(this, orig);
     }
 
     public double getYOffset()
@@ -947,6 +1051,11 @@
 
     public EnumStatus sleepInBedAt(int i, int j, int k)
     {
+        EnumStatus customSleep = ForgeHooks.sleepInBedAt(this, i, j, k);
+        if (customSleep != null)
+        {
+            return customSleep;
+        }
         if (!worldObj.isRemote)
         {
             if (isPlayerSleeping() || !isEntityAlive())

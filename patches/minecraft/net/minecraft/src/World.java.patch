--- ../src_base/minecraft/net/minecraft/src/World.java
+++ ../src_work/minecraft/net/minecraft/src/World.java
@@ -8,8 +8,17 @@
 import java.util.Random;
 import java.util.Set;
 
+import net.minecraftforge.common.Orientation;
+
 public abstract class World implements IBlockAccess
 {
+    /**
+     * Used in the getEntitiesWithinAABB functions to expand the search area for entities.
+     * Modders should change this variable to a higher value if it is less then the radius 
+     * of one of there entities.
+     */
+    public static double MAX_ENTITY_RADIUS = 2.0D;
+    
     /**
      * boolean; if true updates scheduled by scheduleBlockUpdate happen immediately
      */
@@ -273,7 +282,8 @@
     public boolean blockHasTileEntity(int par1, int par2, int par3)
     {
         int var4 = this.getBlockId(par1, par2, par3);
-        return Block.blocksList[var4] != null && Block.blocksList[var4].hasTileEntity();
+        int meta = this.getBlockMetadata(par1, par2, par3);
+        return Block.blocksList[var4] != null && Block.blocksList[var4].hasTileEntity(meta);
     }
 
     /**
@@ -2562,8 +2572,7 @@
      */
     public boolean doesBlockHaveSolidTopSurface(int par1, int par2, int par3)
     {
-        Block var4 = Block.blocksList[this.getBlockId(par1, par2, par3)];
-        return var4 == null ? false : (var4.blockMaterial.isOpaque() && var4.renderAsNormalBlock() ? true : (var4 instanceof BlockStairs ? (this.getBlockMetadata(par1, par2, par3) & 4) == 4 : (var4 instanceof BlockHalfSlab ? (this.getBlockMetadata(par1, par2, par3) & 8) == 8 : false)));
+        return isBlockSolidOnSide(par1, par2, par3, Orientation.UP);
     }
 
     /**
@@ -3917,4 +3926,65 @@
             var7.destroyBlockPartially(par1, par2, par3, par4, par5);
         }
     }
+    
+    /**
+     * Adds a single TileEntity to the world.
+     * @param entity The TileEntity to be added.
+     */
+    public void addTileEntity(TileEntity entity) 
+    {
+        List dest = scanningTileEntities ? addedTileEntityList : loadedTileEntityList;
+        if(entity.canUpdate())
+        {
+            dest.add(entity);
+        }
+    }
+    
+    /**
+     * Determine if the given block is considered solid on the
+     * specified side.  Used by placement logic.
+     * 
+     * @param X Block X Position
+     * @param Y Block Y Position
+     * @param Z Block Z Position
+     * @param side The Side in question
+     * @return True if the side is solid
+     */
+    public boolean isBlockSolidOnSide(int X, int Y, int Z, Orientation side)
+    {
+        return isBlockSolidOnSide(X, Y, Z, side, false);
+    }
+    
+    /**
+     * Determine if the given block is considered solid on the
+     * specified side.  Used by placement logic.
+     * 
+     * @param X Block X Position
+     * @param Y Block Y Position
+     * @param Z Block Z Position
+     * @param side The Side in question
+     * @param _default The defult to return if the block doesn't exist.
+     * @return True if the side is solid
+     */
+    public boolean isBlockSolidOnSide(int X, int Y, int Z, Orientation side, boolean _default)
+    {
+        if (X < -30000000 || Z < -30000000 || X >= 30000000 || Z >= 30000000)
+        {
+            return _default;
+        }
+        
+        Chunk var5 = this.chunkProvider.provideChunk(X >> 4, Z >> 4);
+        if (var5 == null || var5.isEmpty())
+        {
+            return _default;
+        }
+        
+        Block block = Block.blocksList[getBlockId(X, Y, Z)];
+        if(block == null)
+        {
+            return false;
+        }
+        
+        return block.isBlockSolidOnSide(this, X, Y, Z, side);
+    }
 }
